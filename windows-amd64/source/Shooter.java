/* autogenerated by Processing revision 1281 on 2022-02-21 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Shooter extends PApplet {

/* 
 COMP 1501 Project Demo
 GROUP MEMBERS: Declan Diderich, Hunter McCulloch
 DATE: April 4th, 2016
 */
Animation sky, blink;

PImage bg; //the background, I figured there might be some practicality to making it global
ArrayList <Bullet> bullets = new ArrayList<Bullet>(); //this has all the bullets
ArrayList<Enemy> enemies;
ArrayList <Item> items = new ArrayList<Item>(); //This has all the enemies
ArrayList<Obstacle> objects;

Player player; //The player
GM gm;

PImage dTitleLet[]; 
PImage cliff, dCliff, dSky;

int t;
int credits = 0;
int pro = 0;
int numEyes = 180;
int numTLetters = 8;
ArrayList flowers, dFlowers, titleLetters, eyes;
int state = 0; 
int numItems = 0;
int time;
int numFlowers = 20;
int numFlowersT = numFlowers* numFlowers;
Sun titleSun;
Sleep fatigue = new Sleep();

 public void setup() {
  /* size commented out by preprocessor */; //creates screen size 800 pixels by 600 pixels
  frameRate(60); 
  gm = new GM();
  enemies = gm.currentLevel.enemies;
  player = new Player(400,300);
  t = 1;
  dTitleLet = new PImage[8];
  cliff = loadImage("cliff1.png"); //loads the cliff image
  dCliff = loadImage("dCliff1.png"); //loads the dark cliff image
  //Obstacle obstacle1 = new Obstacle(145,655,125,150);
  Obstacle obstacle2 = new Obstacle(145,170,195,470);
  Obstacle obstacle3 = new Obstacle(220,570,470,495);
  Obstacle obstacle4 = new Obstacle(630,655,200,495);
  objects = new ArrayList();
  //objects.add(obstacle1);
  objects.add(obstacle2);
  objects.add(obstacle3);
  objects.add(obstacle4);

  titleSun = new Sun(500, 25, "sun1"); //loads the sun's image

  sky = new Animation("sky", 10); //makes a new animation for the sky
  blink = new Animation("blink", 7); //makes a new animation for blinking

  flowers = new ArrayList(numFlowersT); //makes an array of flowers
  dFlowers = new ArrayList(numFlowersT); //makes an array of dark flowers
  eyes = new ArrayList(numEyes); //makes an array of backgorund numbers
  titleLetters = new ArrayList(8); //makes an array of title letters
    items = new ArrayList(numItems); //makes an array of title letters

  for (int i = 0; i< 8; i++)
    dTitleLet[i] = loadImage("dTitleLet" + (i+1) + ".png");

  for (int i = 0; i < numFlowers; i++) // displays rows and columns of flowers to prevent farther flowers from overlapping closer flowers
    for (int j = 0; j < numFlowers; j++)
      flowers.add(new Flower(i*50 + random(40), 345 + j*20 + random(10), 0, 200, 3000));
  
  for (int i = 0; i < numFlowers; i++) // displays rows and columns of flowers to prevent farther flowers from overlapping closer flowers
    for (int j = 0; j < numFlowers; j++)
      dFlowers.add(new Flower(i*50 + random(40), 345 + j*20 + random(10), 1, 200, 3000));

  for (int i = 0; i<numEyes; i++)  
    eyes.add(new Eye((i*40)%920, (i*30)%500, 100));

  for (int i = 0; i < 8; i++)
    titleLetters.add(new BouncingLetter(i*75, 0, ("titleLet" + (i + 1))));
}

 public void drawCredits() {
  background(0);
  textSize(32);
  textAlign(CENTER);
  fill(255);

  if (credits == 0)
    text("Hunter McCulloch", width/2, height/2);

  else if (credits == 1)
    text("Declan Diderich", width/2, height/2);

  else if (credits >= 2)
    state = 1;
}

 public void drawMenuA() {
  t++;
  sky.play(0, 0, (40000/(t*0.001f)));

  titleSun.update(); //updates the sun's position

  image(cliff, 0, 345);

  for (int i = 0; i < numFlowersT; i++) { //draws each flower individually
    Piece a = (Piece)flowers.get(i);
    a.update();
  }

  ((Piece)titleLetters.get(0)).update();
  for (int i = 1; i < numTLetters; i++) {
    Piece a = (Piece)titleLetters.get(i);
    Piece b = (Piece)titleLetters.get(i-1);
    if (b.getY() >= 150) {
      a.update();
    }
  }

  if ((t > 500)&& ((t % 100)<50)) {
    textSize(32);
    textAlign(CENTER);
    fill(255);
    text("PRESS ENTER", width/2, height/2 + 100);
  }
  if (t>1400)
    blink.play(0, 0, 120);  
  if (t>1480)
    state = 2;
}

 public void drawMenuB() {
  t++;

  textSize(32);
  textAlign(CENTER);
  fill(255);

  background(0);

  for (int i = 0; i<numEyes; i++) {
    Piece a = (Piece)eyes.get(i);
    a.update();
  }

  for (int i = 0; i<8; i++){
    Piece a = (Piece)titleLetters.get(i);
    image(dTitleLet[i], a.getX(), a.getY()); 
  }
  image(dCliff, 0, 345);

  for (int i = 0; i < numFlowersT; i++) { //draws each flower individually
    Flower a = (Flower)dFlowers.get(i);
    a.update();
  }
  if ((t > 1000)&& ((t % 10)<5)) {
    textSize(32);
    textAlign(CENTER);
    fill(0);
    text("HURRY!", width/2, height/2 + 100);
  }
  }

 public void drawPrologue() {
  background(0);
  textSize(14);
  textAlign(CENTER);
  fill(255);

  if (pro == 0)
    text("For months, a pandemic has been rapidly infecting and killing the entire population of the world.", width/2, height/2);
  else if (pro == 1)
    text("Living isolated in a countryside home, you have escaped catching the disease...", width/2, height/2);
  else if (pro == 2)
    text("Until now. Its effects: falling asleep will kill you.", width/2, height/2);
  else if (pro == 3)  
    text("Move with the WASD Keys\nAim with the mouse and shoot by clicking\nCollect caffeine to stay awake.", width/2, height/2);
  else if(pro == 4)
    text("Survive the hordes of enemies and make it to the hospital to find the cure!",  width/2, height/2);
  else if (pro > 4)
    state = 4;
}

 public void drawGame() {
  gm.draw();
  for (int count = 0; count < bullets.size(); count ++) {
    bullets.get(count).draw();
  }
  for (int i = 0; i<items.size(); i++) {
    items.get(i).update();
  }
  for (int i = 0; i<objects.size(); i++) {
    objects.get(i).draw();
  }
  player.draw();
  for (int count = 0; count < enemies.size(); count ++) {
    enemies.get(count).draw();
  }
  println("" + mouseX + "/n" + mouseY);
}

 public void draw() {
  if (state == 0) //This is where I check the game state is on the title splash, anything that you have in your draw method for the titleSplash you'll want inside this
    drawCredits();
  else if (state == 1) 
    drawMenuA();
  else if (state == 2)
    drawMenuB();
  else if (state == 3)  
    drawPrologue();
  else if (state == 4)
    drawGame();
  else{
    println("paused");
    gm.draw();
  }
}

 public void keyPressed() {
  if (state == 0)
    credits++;
  else if (state == 1 || state == 2)
    state = 3;
  else if (state == 3)
    pro++;
  else if (state == 4) {
    if (key == 'w') {
      player.speedY += -2;
    } else if (key == 's') {
      player.speedY += 2;
    }
    if (key == 'a') {
      player.speedX += -2;
    } else if (key == 'd') {
      player.speedX += 2;
    }
    }
    if(state == 4 || state == 5){
      if(key == ' '){
      
      if(gm.currentLevel.state == -2){
        state = 1;
      }
      else if(gm.currentLevel.state == -1){
        state = 4;
        gm.currentLevel = gm.tempLevel;
        gm.currentLevel.initialize(gm.currentLevel.state);
      }
      else if(gm.currentLevel.state == -3){
        state = 4;
        gm.currentLevel = new Level(gm.tempLevel.state + 1);
      }
      else{
        gm.tempLevel = gm.currentLevel;
        gm.currentLevel = new Level(-1);
        state = 5;
      }
      }
      

      if(key == '1'){
        player.gun.changeTo("pistol");
      }else if(key == '2'){
        player.gun.changeTo("machinegun");
      }else if(key == '3'){
        player.gun.changeTo("shotgun");
      }else if(key == '4'){
        player.gun.changeTo("railgun");
      }
    }
}

 public void mouseClicked(){
    if (state == 4){
      player.gun.shoot(player);
    }
    else if(state == 5){
      if(gm.currentLevel.state == -1){
        if(mouseX > 250 && mouseX < 420 && mouseY > 200 && mouseY < 250){
          gm.currentLevel = gm.tempLevel;
          state = 4;
        }
        else if(mouseX > 250 && mouseX < 420 && mouseY > 265 && mouseY < 330){
          gm.currentLevel = new Level(0); //TO THE TITLE SCREEN
          state = 1;
        }
        else if(mouseX > 250 && mouseX < 420 && mouseY > 345 && mouseY < 415){
          stop();
        }
      }
    }
}

 public void keyReleased() { //I should say that my whole movement system could be improved, I have it so that upon the key press speed is added and on the key released it takes it away, however this causes the odd problem when a frame is skipped or pressing like three at a time. If you guys can think of something better no offense taken

  if (state == 4) {
    if (key == 'w') {
      player.speedY = 0;
    } else if (key == 's') {
      player.speedY = 0;
    }
    if (key == 'a') {
      player.speedX = 0;
    } else if (key == 'd') {
      player.speedX = 0;
    }
  }
}

public float time(float i){
return (i * 60);
}
public class Animation{
  PImage aFrames[];
  String fullName;
  int len, frame, timer;
  float speed, delay, cXp;

  Animation(){  fullName = "";  len = 0;  frame = 0;  speed = 0;  delay = 0;  timer = 0;  cXp = 0;}
  
  Animation (String imName, int lenIn){
    len = lenIn; //number of frames in animation
    aFrames = new PImage[len]; //array which will contain all frames of animation
    
    for (int i = 0; i<len; i++){ //for every frame in the animation
      fullName = imName + (i+1) + ".png"; //make the image load the correct frame (all frames have the same initial name with the only difference of the number
      aFrames[i] = loadImage(fullName); //sets the current position of the array to the corresponding frame
    }
  }
  
   public void play(float x, float y, float speedIn){ //plays the animation repeatedly
    speed = speedIn;
    if (millis() > timer + speed){
      frame = (frame+1) % len; //the frame is the remainder of the next frame divided by the total length; once last frame reached, it resets to zero
      timer = millis();
    }
    image(aFrames[frame], x, y); //display current frame   
  } 
  
  
}
public class BouncingLetter extends Piece{ //This is the bouncing letter object
  int state;
  float speed, acc;
  PImage letterImage;
  
  BouncingLetter() { super();}  
  
  BouncingLetter(float xin, float yin, String imIn){
    super(xin, yin, imIn);
    state = 0;
    speed = 3;
    acc = .015f; //you can mess around with these variables a bit more if you aren't satisfied with the bounce
  }
  
   public void update(){
    if(state == 0 || state == 3){
      y += speed;
      speed += speed * acc;
      x += 1;
    }
    else if(state == 1){
     y -= speed;
     speed -= speed * acc;
     x += 1;
    }
    if(y >= 300 && state == 0){
      state = 1;
      speed = 2;
    }
    else if(y <= 250 && state == 1){
      state = 3;
    }
    else if( y >= 300 && state == 3){
      state = 4;
    }
    display();
  }
   public void display(){  image(im, x, y);}
}
//basically this whole class is used only by the gun class so you shouldn't have to worry about it
class Bullet extends Sprite{
  int bulletSpeed, damage, penetration, lifeSpan; //penetration is the collisions the bullet can have with Sprites
  Sprite owner; //Who shot the bullet
  PVector mDir; //the vector that points from bullet to the mouse
  
  Bullet(float xDir, float yDir, PImage imageArg, Sprite object, int damageArg, int penetrationArg, int lSpan){
    image = imageArg;
    if(xDir == 0 && yDir == 0){
      xDir = 1;
    } 
    this.hit();
    bulletSpeed = 2;
    x = object.x;
    y = object.y;
    owner = object;
    damage = damageArg;
    penetration = penetrationArg;
    edgeMode = "destroy";
    mDir = null;
    speedX = xDir;
    speedY = yDir;
    lifeSpan = lSpan;
  }

    public void draw(){
    this.x += speedX;
    this.y += speedY;
    this.lifeSpan--;
    if(alive){
      image(image, x, y);
    }
    if(!stopAndTrack){ //The Enemy class has a stopandtrack mode that would be messed if the updateDirection function happened
      updateDirection();
    }
    if(immune){ //Set immune to true and immuneTimer to seconds*60 to make the mob immune for this time
      immuneTimer --;
      if(immuneTimer <= 0){
        immune = false;
      }
    }
    edges();
    checkForHit();
    if(!alive){
      kill();
    }
    if (lifeSpan <= 0)
    kill();
  }
    
   public void checkForHit(){ //based on the owner sees if anything has been hit
    if(owner == player){
      for(int i = 0; i < enemies.size(); i ++){
        Enemy enemy = enemies.get(i);
        if(distanceTo(enemy) < 20){
          enemy.health -= damage;
          println("Enemy Hit");
          enemy.hit();
          penetration --;
          if(penetration == 0){
            alive = false;
          }
        }
      }
    }
    else{
      if(distanceTo(player) < 20){
        player.health -= damage;
        kill();
      }
    }
  }
  
   public void kill(){
    println("Bullet Killed");
    for(int i = 0; i < bullets.size(); i ++){
      if(bullets.get(i) == this){
        bullets.remove(i);
      }
    }
  }
}
/* Okay so the enemy system I've put through is pretty straight forward, at the bottom you'll see examples of possible enemies, in order to make an enemy that is considered separate
from the other enemy objects you have to create a new enemy passing in one of the example classes. ie: Enemy enemy = new enemy(RangedExample), dont forget the enemy must be 
added to the enemies arrayList
*/

class Enemy extends Sprite{
  Gun gun;
  float health,  oldX, oldY; //changed to float
  float healthMax; //added to keep the bars the same length
  int attackRange, worth;
  float speed;
  String followPattern; //So far all I have is "ranged" or "melee", the only thing this changes is that the ranged enemies stop moving when within range
  int ran = 0, fleeTimer = 0;
  
  
  Enemy(){
    immune = false;
    alive = true;
    edgeMode = "collide";
  }
  
  Enemy(Enemy enemy){
  health = enemy.health;
  healthMax = enemy.healthMax;
  gun = new Gun(enemy.gun);
  speed = enemy.speed;
  attackRange = enemy.attackRange;
  worth = enemy.worth;
  followPattern = enemy.followPattern;
  ani = enemy.ani;
  
  immune = false;
  alive = true;
  edgeMode = "collide";  
  ran = (int)random(4);
  switch(ran){
  case 0: x = 0; y = 100; break;
  case 1: x = 790; y = 0; break;
  case 2: x = 790; y = 590; break;
  case 3: x = 0; y = 590; break;
  default: x = 790; y = 590; break;
  }
}
  
   public void draw(){
    super.draw();
    gun.draw();
    if (fleeTimer > 0)
      fleeTimer--;
    if(attackDecision()){
      gun.shoot(this);
    }
    movement();
    if(health <= 0){
      alive = false;
    }
    if(!alive){
      kill();
    }
      drawEnemyBar();
  }
  
   public void kill(){ //gets rid of the enemy
    println("Enemy Killed");
    for(int i = 0; i < enemies.size(); i ++){
      if(enemies.get(i) == this){
        enemies.remove(i);
        drop();
      }
    }
  }
  
   public void drop(){
    int r = (int)random(100);
    if (r > 90){
      numItems++; 
      items.add(new Item(this.x, this.y, numItems, items, 3));
    }
    else if (r > 75){
      numItems++; 
      items.add(new Item(this.x, this.y, numItems, items, 2));    
    }
      else if (r > 60){
      numItems++; 
      items.add(new Item(this.x, this.y, numItems, items, 1));
      }
  }
  
   public void movement(){ //You'll simply have to make more else if's for more followPatterns if you want them
    PVector v0;
    float dst;

    oldX = x;
    oldY = y;
    
    for(int i = 0; i < enemies.size(); i ++){
     if(distanceTo(enemies.get(i)) < 20 && this != enemies.get(i)){
      if (fleeTimer <= 0){
       flee(speed, enemies.get(i));
       fleeTimer = 10;
       println("Meow");
      }
     }
    }
    if(fleeTimer<= 0){
    if(followPattern.equals("ranged")){
      if(distanceTo(player) > attackRange){
        follow(speed, player);
        stopAndTrack = false;
      }
    else if (distanceTo(player) < attackRange){
      flee(speed, player);
    }
    else{stopAndTrack(player);} //this stopandtrack thing makes the enemy stop moving and just shoot when it's within range
    }
    else if(followPattern.equals("melee")){
      follow(speed, player);
    }
    }
  
    if(evade){
      evadeTimer --;
      
      
//    for (int i = 0; i<objects.size(); i++){
      Obstacle a = closestObject();//(Obstacle)objects.get(i);
      
      dst=dist(x, y, a.x, a.y);
      v0= new PVector((a.x-x)/dst,(a.y-y)/dst); 
      v0.rotate(radians(45));

      if(evadeTimer <= 0){
        evade = false;
      }

      //v1=new PVector(cos(radians(90))*v0.x-sin(radians(90))*v0.y, sin(radians(90))*v0.x+cos(radians(90))*v0.y); 
      v0.normalize();
      speedX = v0.x*speed;
      speedY = v0.y*speed;
}
   } 
    
      
      /*{
        x = oldX;
        y = oldY;
        if(enemies.get(i).x > this.x){
          this.speedX = -1;
        }else{
          this.speedX = 1;
        }
        if(enemies.get(i).y > this.y){
          this.speedY = -1;
        }else{
          this.speedY = 1;
        }
      }*/

  
   public int checkObjects(){
    int closest = 1000;
    for(int i = 0; i < objects.size(); i ++){
      if(distanceTo(objects.get(i)) < closest){
        closest = distanceTo(objects.get(i));
      }
    }
    return closest;
  }
     public Obstacle closestObject(){
    int closest = 1000;
    Obstacle a = new Obstacle();
    for(int i = 0; i < objects.size(); i ++){
      if(distanceTo(objects.get(i)) < closest){
        closest = distanceTo(objects.get(i));
        a = objects.get(i);
      }
    }
    return a;
  }

  
   public boolean attackDecision(){ //simply sees if the enemy should attack
    if(distanceTo(player) <= attackRange){
      return true;
    }
    return false;
  }
  
   public void drawEnemyBar(){ //draws a small blue bar above the enemy's head
    stroke(0,0,255);
    fill(0,0,255); 
    rect(this.x-5, this.y + 25, health/healthMax*5, 5);
  }
}

      /*int biggest = 0;
      x += 10;
      biggest = checkObjects();
      speedX = 1;
      speedY = 0;
      x -= 20;
      if(checkObjects() > biggest){
        biggest = checkObjects();
        speedX = -1;
        speedY = 0;
      }
      x += 10;
      y += 10;
      if(checkObjects() > biggest){
        biggest = checkObjects();
        speedX = 0;
        speedY = 1;
      }
      y -= 20;
      if(checkObjects() > biggest){
        biggest = checkObjects();
        speedX = 0;
        speedY = -1;
      }
      y += 10;
    }*/
public class Eye extends Piece {
  Animation ani;
  int speed, delay;

  public Eye(float xin, float yin, int spd) { //creates a flower
    super(xin, yin);
    speed = spd;
    ani = new Animation("eye", 16);
  } //end FlowerConstructor

  public void update() {
    timer++;
    display();
  }

  public void display() {
    if (timer >= 500)
      ani.play(x, y, speed);
    }
  }
public class Flower extends Piece{
  WaveAnimation ani;
  int speed, delay, type;
  
  public Flower(){  super();}
  
  public Flower(float xin, float yin, int t, int spd, int dly){ //creates a flower
    super(xin, yin);
    type = t;
    speed = spd;
    delay = dly;
    
    switch (type){ //declare the animation types here, to avoid declaring them in main
      case 0:  ani = new WaveAnimation("bFlower", 9);  break;
      case 1:  ani = new WaveAnimation("dFlower", 9); break;
    }//end typeSwitch
  } //end FlowerConstructor
  
  public void update(){  
    display();
  }
  
  public void display(){  
    switch (type){
      case 0: ani.progWavePlay(x, y, speed, delay, 10, 1000); 
      case 1: ani.progWavePlay(x, y, speed, delay, 10, 1000); 
      default: break;
    }
  }
  public void setType(int t){  type = t;}
}
// I usually make a GM class (game manager) to handle the actual game structure, this handles the levels, enemy spawning, etc..

class GM{
  Level currentLevel, tempLevel;
  int stage; //this is the actual level number, for the titles screen/credits/whatever else that isn't an actual level I would just use specific things like -1, -2, etc
  
  GM(){
    //imageMode(CENTER);
    frameRate(60);
    stage = 1;
    currentLevel = new Level(stage); //pass in the stage you want to make, is you wanted a store or pause screen or something you access in the middle of a stage you would have to have currentLevel as well as a tempLevel, so that you can revert back to the currentLevel when unpaused or whatever
  }
  
   public void draw(){
    currentLevel.draw();
    //if(enemies.size() == 0 && currentLevel.enemyPower <= 0){ //If all enemies are killed a new level is initialized
      //bullets = new ArrayList<Bullet>();
      //stage ++;
      //currentLevel.initialize(stage);
      //player.x = 400; player.y = 300; //sets player to center of screen
    //}
  }
}
class Gun{
  int damage, penetration, lifeSpan, drain; //reload you will set in seconds, reloadTimer takes care of itself, I should also mention that reload is just the time between shots not between magazines or anything like that
  float reload,reloadTimer;
  PImage bulletImage;
  /* Okay so my bullet system might be a little overcompliacted I'm not sure, but when you make a new gun, in order to change the bullet images, you must call the newBullet
  function and pass in (stay with me here) the name of the folder that these images are in. You'll notice in the data folder one called arrow, slash, and bullet. In these
  folders are 8 images, each representing a direction the bullet can go. These images must be .png, and labeled name0 through name7, name0 being the bullet pointing straight 
  up, name1 45 degrees clockwise of that, etc. If you've got the player rotating with the mouse and everything then it will probably be easier just to have one image that you 
  rotate based on the players rotation. I simply didn't get around to figuring out how to do this. */
  
  boolean canShoot;
  String name; //I used this so that you can have premade guns, please see the function called changeTo
  
  Gun(){ //3 constructors, this defaults the gun to the pistol
    changeTo("pistol");
    canShoot = true;
  }
   Gun(Gun other){
    this.bulletImage = other.bulletImage;
    this.damage = other.damage;
    this.reload = other.reload;
    this.reloadTimer = this.reload;
    this.penetration = other.penetration;
    canShoot = true;
    this.lifeSpan = other.lifeSpan;
  }
  Gun(int damage, float reload, int lSpan){ //pass in reload (in seconds) and damage
    this.damage = damage;
    this.reload = time(reload);
    reloadTimer = this.reload;
    penetration = 1;
    canShoot = true;
    lifeSpan = lSpan;
  }
  Gun(int damage, float reload, int penetration, int lSpan){ //also pass in penetration (otherwise will be 1)
    this.damage = damage;
    this.reload = time(reload);
    this.penetration = penetration;
    reloadTimer = this.reload;
    penetration = 1;
    canShoot = true;
    lifeSpan = lSpan;  
  }
  
   public void draw(){
    timers();
  }
  
   public void timers(){ //handles reload right now
    if(!canShoot){
      reloadTimer --;
      if(reloadTimer <= 0){
        canShoot = true;
        reloadTimer = reload;
      }
    }
  }
  
   public void shoot(Sprite object){ //The gun shoots, pass in who shot it
    PVector dir;
    if (object == player)
      dir = new PVector(mouseX - object.x, mouseY-object.y);
    else
      dir = new PVector(player.x - object.x, player.y-object.y);

      dir.setMag(5);
    if(canShoot){
      fatigue.sleepValue -= drain;
      Bullet b = new Bullet(dir.x, dir.y, bulletImage, object, damage, penetration, lifeSpan);
      bullets.add(b);
      canShoot = false;
    }
  }
  
   public void changeTo(String nameArg){ //This is where you can changeto preset weapons
    name = nameArg; 
    if(name.equals("pistol")){ //A pretty basic example, imitate with different specifics to create other weapons
      bulletImage = loadImage("bullet.png");
      damage = 10;
      reload = time(1);
      reloadTimer = reload;
      penetration = 1;
      drain = 100;
      lifeSpan = 70;
   }
      else if(name.equals("machinegun")){
     bulletImage = loadImage("MACHINEGUNBULLET.png");
     damage = 5;
     reload = time(0);
     reloadTimer = reload;
     penetration = 1;
     drain = 50;
     lifeSpan = 60;

   }
   else if(name.equals("shotgun")){
     bulletImage = loadImage("SHOTGUNBULLET.png");
     damage = 50;
     reload = time(3.5f);
     reloadTimer = reload;
     penetration = 3;
     drain = 200;
     lifeSpan = 30;

   }
   else if(name.equals("railgun")){
     bulletImage = loadImage("RAILGUNSHOT.png");
     damage = 25;
     reload = time(2.75f);
     reloadTimer = reload;
     penetration = 100;
     drain = 350;
     lifeSpan = 200;

   }
  }
} 
public class Item extends Piece{
  
int CBOOST1 = 1;
int CBOOST2 = 2;
int CBOOST3 = 3;
int type;

  public Item(float xin, float yin, int idin, ArrayList oin, int type){
      super(xin, yin, idin, oin);
      this.type = type;
      
      switch(type){
      case 1: im = loadImage("cBoost1.png");break;
      case 2: im = loadImage("cBoost2.png");break;
      case 3: im = loadImage("cBoost3.png");break;
      default: break;
    }
  }
  
   public void update(){
    timer++;
  if ((timer % 40)<20) {
    y+=0.1f;
  }
  else{
    y-=0.1f;
  }
  if (timer <= 1000){
    pickUp();
    display();
  }
  else if(timer >1000 && timer <1500){
    if ((timer % 20)<10) {
       pickUp();
    display();
   
  }
  else
    pickUp();
  }
  else{
   for(int i = 0; i < items.size(); i ++){
        if(items.get(i) == this){
          items.remove(i);
    }
  }
  }
  }
  
   public void display(){
    image(im, x, y);
  }
  
   public void pickUp(){
    println(distanceTo(player));
    if (distanceTo(player) < 30){
      println("ITEM PICKUP");
      switch(type){
      case 1: fatigue.smallPickup(); break;
      case 2: fatigue.mediumPickup(); break;
      case 3: fatigue.largePickup(); break;
      default: break;
      }
      for(int i = 0; i < items.size(); i ++){
        if(items.get(i) == this){
          items.remove(i);
    }
  }
}
}
}
class Level{
  PImage bg;
  int enemyPower, state, guns;
  float spawn, spawnTimer;
  ArrayList<Enemy> enemyList = new ArrayList<Enemy>(); //this list is the possible enemies that could show up on that level
  ArrayList<Enemy> enemies = new ArrayList<Enemy>();
  Level(int stage){
    enemyPower = 0;
    bg = null;
    state = stage;
    initialize(state);
  }
  
   public void draw(){
    image(bg, 0, 0);
    if (enemyPower > 0){
    if(state != 0){
      enemyTimer();
    }
    }
    else if(enemies.size() == 0 && state > 0){
      state = 5;
      initialize(-3);
    }
    if(!player.alive && this.state != -2 && this.state != -1){
      initialize(-2);  //GAME OVER CODE HERE
    }
  }
  
   public void enemyTimer(){ //this handles enemy spawning, they all spawn in the top left corner right now but this can be easily changed
    spawnTimer --;
    if(spawnTimer <= 0){
      enemies.add(chooseEnemy());
      spawnTimer = spawn;
    }
  }
  
   public Enemy chooseEnemy(){ //Upon spawning of an enemy, a type of enemy from the list for this level is chosen to spawn
    Enemy chosen;
    do{
      chosen = enemyList.get(PApplet.parseInt(random(0,enemyList.size())));
    }while(chosen.worth > enemyPower);
    enemyPower -= chosen.worth;
    return new Enemy(chosen);
  }
   public void initialize(int stageArg){ //This is where all the levels/screens are created
    state = stageArg;
    
    if(state == 10){
      //access the title screen here
    }

     else if(state == -1){
      bg = loadImage("pause.png"); //replace
    }
    else if(state == -2){
      bg = loadImage("gameover.png");
    }
    else if(state == -3){
      bg = loadImage("win.png");
    }
    else if(state == 1){ //You will have to do all of the following for every level you make
      bg = loadImage("lvl1Bg.png"); //set background
      enemyPower = 20; //set the total powerLevel of enemies that will spawn
      spawn = time(3); //sets how fast a new enemy will spawn in seconds
      spawnTimer = spawn; //you need this
      enemyList = new ArrayList<Enemy>(); //recreate this list each time, add the type of enemies that you want the level to spawn (one instance of each)
      enemyList.add(new MeleeExample());
      enemyList.add(new RangedExample());
      guns = 4;
    }
    
    //When a stage is completed, the stage number is increased and the level at that number is initialized, so if there is an end game screen, you will want it to have the stage number after the last stage
  }
}
class MeleeExample extends Enemy{
  MeleeExample(){
    health = 50;
    healthMax = 10;
    attackRange = 50;
    speed = 1;
    worth = 1;
    gun = new Gun(20, 2, 3); //damage then reload respectively
    gun.bulletImage = loadImage("slash.png");
    ani = new Animation("melee", 2);
    followPattern = "melee";
  }
  
   public void draw(){
    super.draw();
  }
}
class Obstacle extends Sprite{
  int x1, x2, y1, y2; //x1, y1 is top left corner, x2, y2 is bottom right
  Obstacle(){
    super();
    image = loadImage("player1.png");
  }
  Obstacle(int x1, int x2, int y1, int y2){
    super();
    image = loadImage("player1.png");
    this.x1 = x1;
    this.x2 = x2;
    this.y1 = y1;
    this.y2 = y2;
  }
   public void draw(){
    collision(player);
    for(int i = 0; i < enemies.size(); i ++){
      collision(enemies.get(i));
    }
    for(int i = 0; i < bullets.size(); i ++){
      collision(bullets.get(i));
    }

  }
   public void collision(Bullet pew){
  if(pew.x > x1-5 && pew.x < x2+5 && pew.y > y1-5 && pew.y < y2+5)
    pew.kill();
  }
  
   public void collision(Sprite object){
    PVector avg = new PVector(object.x+16, object.y+16);
    if(avg.x > x1-10 && avg.x < x2+10 && avg.y > y1-10 && avg.y < y2+10){
      if(avg.x < x1 + 5){
        if(object.speedX > 0)
          object.speedX = 0;
        
      }
      else if(avg.x > x2-5){
        if(object.speedX < 0)
          object.speedX = 0;
        
      }
      if(avg.y < y1+5){
        if(object.speedY > 0)
          object.speedY = 0;
        
      }
      else if(avg.y > y2 - 5){
        if(object.speedY < 0)
          object.speedY = 0;
        
      }
      if(object != player){ //TAKE THIS STATEMENT OUT TO STOP THE ENEMIES FROM DOING THAT WEIRD WALL THING
        object.evade = true;
        object.evadeTimer = 30;
      }
    }
  }
}
public abstract class Piece{
  float x, y;
  int id, timer;
  PImage im;
  ArrayList extras;
  
  Piece() {  x = 0;  y = 0;  id = 0; timer = 0; extras = new ArrayList(null); im = null;}
  
  Piece(float xin, float yin, int idin, ArrayList oin) {  x = xin;  y = yin;  id = idin;  extras = oin;} //constructor for an object with many copies
  Piece(float xin, float yin, String imIn) {  x = xin;  y = yin;  im = loadImage(imIn+".png");} //constructor for a single object  with a single image
  Piece(float xin, float yin) {  x = xin;  y = yin;} //constructor for a single object with no image
  
  public abstract void update();
  public abstract void display();
  
    public int distanceTo(Sprite object){ //distance to another Sprite
    float distance = sqrt( sq(object.x - this.x) + sq(object.y - this.y) );  
    //return int(sqrt(((object.x - this.x)*(object.x - this.x)) + ((object.y - this.y)*(object.y - this.y))));
    return (int)distance;
  }
  
  public float getX()     {  return this.x;}
  public float getY()     {  return this.y;}
  public float getTimer() {  return this.timer;}
}
class Player extends Sprite{
  Gun gun;
  float health; //changed to float
  float oldX, oldY;

  float healthMax; //added to have the bars start at the same length
  Player(int xArg, int yArg){
    x = xArg;
    y = yArg;
    gun = new Gun(); //defaults to a pistol when no arguments are passed in
    ani = new Animation("player", 4); //ANIMATION
    alive = true;
    immune = false;
    edgeMode = "collide";
    health = 100;
    healthMax = 100;
  }
  
   public void draw(){
    super.draw();
    gun.draw();
    fatigue.draw();
    drawHealthBar(); //does what it says
    moderateSpeed();
    if(health <= 0){
      alive = false;
    }
    if(!alive){
      println("PLAYER DEAD");
      gm.tempLevel = gm.currentLevel;
      gm.currentLevel = new Level(-2);
      state = 5;
    }
    oldX = x;
    oldY = y;
  }
  
   public void moderateSpeed(){ //Stops the player from shooting away when a button is held
    if(speedX >= 2){
      speedX = 2;
    }
    else if(speedX <= -2){
      speedX = -2;
    }
    if(speedY >= 2){
      speedY = 2;
    }
    else if(speedY <= -2){
      speedY = -2;
    }
  }
     public void drawHealthBar(){ //draws a red bar in the top left for the player's health
    stroke(0,0,0);
    strokeWeight(2);
    fill(0,100,0);
    rect(5, 5, healthMax+2, 20);
    strokeWeight(0);
    fill(255,0,0);
    rect(7, 7, health/healthMax *100, 17);
  }
}
class RangedExample extends Enemy{ //So you can make as many of these classes as you want, you'll just have to set each specific parameter as below
  RangedExample(){
    health = 20;
    healthMax = 20;
    attackRange = 150; //in pixels
    speed = 0.5f;
    worth = 1; //See the explanation of the level system in GM, this is the cost to the level to make this enemy
    gun = new Gun(10, 5, 200); //damage, then reload respectively
    gun.bulletImage = loadImage("bullet.png");

    ani = new Animation("archer", 2);
    followPattern = "ranged";
  }
  
   public void draw(){
    super.draw();
  }
}
class Sleep{
  float sleepValue; //amount of stamina
  float sleepMaxTotal = 5000; //starting amount of stamina
  float sleepAttackDamage = 600; //damage done by a stamina based attack
  float sleepPickup = 500; //stamina picked up by an item
  
  Sleep(){
    this.sleepValue = sleepMaxTotal;
  }
  
   public void draw(){
    if (sleepValue > 0 )
    loseSleep();
    if (sleepValue > sleepMaxTotal)
    sleepValue = sleepMaxTotal;
    if(sleepValue <= 0){
      player.health = 0;
      player.alive = false;
    }
    drawSleepBar();
  }
  
   public void loseSleep(){ //loses one stamina point per frame
    sleepValue--;
  }
  
   public float getSleepValue(){ //returns current stamina, could be used for on-screen effects
    return sleepValue;
  }
  
   public void sleepDamage(){ //stamina damage
    sleepValue -= sleepAttackDamage;
  }
  
    public void smallPickup(){ //small stamina pickup
    sleepValue += sleepPickup;
  }
    public void mediumPickup(){ //small stamina pickup
    sleepValue += (sleepPickup*2);
  }
  
  public void largePickup(){ //large stamin pickup
    sleepValue += (sleepPickup * 3);
  }
  
   public void resetSleepValue(){ //start of a level, can give back all stamina, or for very large pickup item
    sleepValue = sleepMaxTotal;
  }
  
   public void sleepUpgrade(){ //end of level total stamna upgrade
    sleepMaxTotal += 600;
  }
  
   public void drawSleepBar(){ //draws a green stamina bar in the top left of the screen.
  /*  stroke(0,255,0);
    rect(5, 30, sleepValue/sleepMaxTotal * 100, 10);
    */
    stroke(0,0,0);
    strokeWeight(2);
    fill(106, 78, 0);
    rect(5, 30, sleepMaxTotal/50+2, 20);
    strokeWeight(0);
    fill(206,178,35);
    rect(7, 32, sleepValue/sleepMaxTotal * 100, 17);
  }
  
}
class Sprite{
  float x, y, dirX, dirY, speedX, speedY, immuneTimer;
  Animation ani; //The sprite
  int evadeTimer;
  PImage image;
  String edgeMode; //Change between "collide" and "destroy" to change what happens when the sprite hits the edge
  boolean stopAndTrack, alive, immune; //these are all state variables
  boolean right, evade; //Specifically for when the player has stopped
  Sprite(){
     stopAndTrack = false;
     immune = false;
     alive = true;
     evade = false;
  }
  Sprite(float x, float y){
    stopAndTrack = false;
    immune = false;
    alive = true;
    this.x = x;
    this.y = y;
    evade = false;
  }
   public void draw(){
    x += speedX;
    y += speedY;
    if(alive){
      ani.play(x-10, y-10, 150); //PLAY ANIMATION (BULLET HAS AN IMAGE)
    }
    if(!stopAndTrack){ //The Enemy class has a stopandtrack mode that would be messed if the updateDirection function happened
      updateDirection();
    }
    if(immune){ //Set immune to true and immuneTimer to seconds*60 to make the mob immune for this time
      immuneTimer --;
      if(immuneTimer <= 0){
        immune = false;
      }
    }
    edges();
  }
  
   public void edges(){ //Edge collision
    if(x > 790){
      if(edgeMode.equals("collide")){
        x = 790;
      }else if(edgeMode.equals("destroy")){
        this.alive = false;
      }
    }else if(x < 10){
      if(edgeMode.equals("collide")){
        x = 10;
      }else if(edgeMode.equals("destroy")){
        this.alive = false;
      }
    }
    if(y > 590){
      if(edgeMode.equals("collide")){
        y = 590;
      }else if(edgeMode.equals("destroy")){
        this.alive = false;
      }
    }else if(y < 10){
      if(edgeMode.equals("collide")){
        y = 10;
      }else if(edgeMode.equals("destroy")){
        this.alive = false;
      }
    }
  }
  
   public void updateDirection(){ //Based on the speed of the sprite, the direction is changed appropriately
    if(speedX > 0){
      dirX = 1;
    }
    else if(speedX < 0){
      dirX = -1;
    }
    else if(this != player){
      dirX = 0;
    }
    else if(!right && speedY == 0){
      dirX = -1;
    }
    if(speedY > 0){
      dirY = 1;
    }
    else if(speedY < 0){
      dirY = -1;
    }
    else{
      dirY = 0;
    }
  }
  
   public void follow(float speed, Sprite object){ //Pass in the speed you want to chase and the other Sprite that you want to chase
    if(object.x > x + 20){
      dirX = 1;
    }
    else if(object.x < x - 20){
      dirX = -1;
    }
    else{
      dirX = 0;
    }
    if(object.y > y + 18){
      dirY = 1;
    }
    else if(object.y < y - 18){
      dirY = -1;
    }
    else{
      dirY = 0;
    }
    speedX = dirX * speed;
    speedY = dirY * speed;
  }
  
   public void flee(float speed, Sprite object){
    if(object.x > x){
      dirX = -1;
    }
    else if(object.x < x){
      dirX = 1;
    }
    else{
      dirX = 0;
    }
    if(object.y > y){
      dirY = -1;
    }
    else if(object.y < y){
      dirY = 1;
    }
    else{
      dirY = 0;
    }
    speedX = dirX * speed;
    speedY = dirY * speed;
  }
   public void stopAndTrack(Sprite object){ //This is only used for the ranged enemy right now, the enemy still tracks the player to shoot at just without moving
    follow(0, object);
    stopAndTrack = true;
  }
  
   public int distanceTo(Sprite object){ //distance to another Sprite
    float distance = sqrt( sq(object.x - this.x) + sq(object.y - this.y) );  
    //return int(sqrt(((object.x - this.x)*(object.x - this.x)) + ((object.y - this.y)*(object.y - this.y))));
    return (int)distance;
  }
  
   public void hit(){ //When something is hit it becomes immune for a short period so that the bullet doesnt collide multiple times
    immune = true;
    immuneTimer = 30;
  }
}
public class Sun extends Piece{

  public Sun(){  super();}
  
  public Sun(float xin, float yin, String imIn){super(xin, yin,imIn);}
  
  public void update(){
     timer++;
     x-=0.1f;
     y+=(sq(timer/500)/500);
     display();
  }
  
  public void display(){
    image(im, x, y);
  }
}
public class WaveAnimation extends Animation{

  public WaveAnimation() {  super();}
  
  public WaveAnimation(String imName, int lenIn) {  super(imName, lenIn);}
  
   public void progWavePlay(float x, float y, int speedIn, int delayIn, int freqIn, int limIn){ //plays the animation with a delay on the whole thing, as well as a wave from left to right
    speed = speedIn; 
    delay = delayIn;

    if (((this.frame % len) == 0)&&(x<= cXp)&&(millis()>timer+delay)) //if the object is standing still, and it needs to be updated, and its delay timer is up:
              frame = (frame+1) % len; //the frame is the remainder of the next frame divided by the total length; once last frame reached, it resets to zero
 
    else if (((this.frame % len) != 0)&&(millis()>timer+speed)){ //otherwise, if it's in motion, and its timer is up:
        frame = (frame+1) % len; //the frame is the remainder of the next frame divided by the total length; once last frame reached, it resets to zero
        timer = millis();
    } 
  
    if(millis()>(timer + delay))  cXp+=freqIn;
    if (cXp >limIn)  cXp = 0;

    image(aFrames[frame], x, y); //display current frame
  }
}


  public void settings() { size(800, 600); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Shooter" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
